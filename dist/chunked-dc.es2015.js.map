{"version":3,"file":"chunked-dc.es2015.js","sources":["../src/common.ts","../src/chunker.ts","../src/unchunker.ts","../src/main.ts"],"sourcesContent":["/**\n * Copyright (C) 2016-2018 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\nexport class Common {\n    public static HEADER_LENGTH = 9;\n}\n","/**\n * Copyright (C) 2016-2018 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\n/// <reference path='../chunked-dc.d.ts' />\n\nimport { Common } from './common';\n\n/**\n * A Chunker instance splits up an Uint8Array into multiple chunks.\n *\n * The Chunker is initialized with an ID. For each message to be chunked,\n * a new Chunker instance is required.\n */\nexport class Chunker implements chunkedDc.Chunker {\n\n    private id: number;\n    private chunkDataSize: number;\n    private chunkId: number = 0;\n    private message: Uint8Array;\n\n    /**\n     * Create a Chunker instance.\n     *\n     * @param id An identifier for the message. Must be between 0 and 2**32-1.\n     * @param message The Uint8Array containing the bytes that should be chunked.\n     * @param chunkSize The chunk size *including* header data.\n     */\n    constructor(id: number, message: Uint8Array, chunkSize: number) {\n        if (chunkSize < (Common.HEADER_LENGTH + 1)) {\n            throw new Error('Chunk size must be at least ' + (Common.HEADER_LENGTH + 1));\n        }\n        if (message.byteLength < 1) {\n            throw new Error('Array may not be empty');\n        }\n        if (id < 0 || id >= (2 ** 32)) {\n            throw new Error('Message id must be between 0 and 2**32-1');\n        }\n        this.id = id;\n        this.message = message;\n        this.chunkDataSize = chunkSize - Common.HEADER_LENGTH;\n    }\n\n    /**\n     * Whether there are more chunks available.\n     */\n    public get hasNext(): boolean {\n        const currentIndex = this.chunkId * this.chunkDataSize;\n        const remaining = this.message.byteLength - currentIndex;\n        return remaining >= 1;\n    }\n\n    /**\n     * Iterator implementation. Value is the next Uint8Array chunk.\n     */\n    public next(): IteratorResult<Uint8Array> {\n        if (!this.hasNext) {\n            return {\n                done: true,\n                value: null,\n            };\n        }\n\n        // Allocate chunk buffer\n        const currentIndex = this.chunkId * this.chunkDataSize;\n        const remaining = this.message.byteLength - currentIndex;\n        const chunkBytes = remaining < this.chunkDataSize ? remaining : this.chunkDataSize;\n        const chunk = new DataView(new ArrayBuffer(chunkBytes + Common.HEADER_LENGTH));\n\n        // Create header\n        const options = remaining > chunkBytes ? 0 : 1;\n        const id = this.id;\n        const serial = this.nextSerial();\n\n        // Write to chunk buffer\n        chunk.setUint8(0, options);\n        chunk.setUint32(1, id);\n        chunk.setUint32(5, serial);\n        for (let i = 0; i < chunkBytes; i++) {\n            const offset = Common.HEADER_LENGTH + i;\n            chunk.setUint8(offset, this.message[currentIndex + i]);\n        }\n        return {\n            done: false,\n            value: new Uint8Array(chunk.buffer),\n        };\n    }\n\n    /**\n     * Return and post-increment the id of the next block\n     */\n    private nextSerial(): number {\n        return this.chunkId++;\n    }\n\n    /**\n     * Return an iterator over the chunks.\n     */\n    public [Symbol.iterator](): IterableIterator<Uint8Array> {\n        return this;\n    }\n\n}\n","/**\n * Copyright (C) 2016-2018 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\n/// <reference path='../chunked-dc.d.ts' />\n\nimport { Common } from './common';\n\n/**\n * Helper class to access chunk information.\n */\nexport class Chunk {\n    private _endOfMessage: boolean;\n    private _id: number;\n    private _serial: number;\n    private _data: Uint8Array;\n    private _context: any;\n\n    /**\n     * Parse the ArrayBuffer.\n     */\n    constructor(buf: ArrayBuffer, context?: any) {\n        if (buf.byteLength < Common.HEADER_LENGTH) {\n            throw new Error('Invalid chunk: Too short');\n        }\n\n        // Read header\n        const reader = new DataView(buf);\n        const options = reader.getUint8(0);\n        // tslint:disable-next-line:no-bitwise\n        this._endOfMessage = (options & 0x01) === 1;\n        this._id = reader.getUint32(1);\n        this._serial = reader.getUint32(5);\n\n        // Read data\n        // Note: We copy the data bytes instead of getting a reference to a subset of the buffer.\n        // This is less ideal for performance, but avoids bugs that can occur\n        // by 3rd party modification of the ArrayBuffer.\n        this._data = new Uint8Array(buf.slice(Common.HEADER_LENGTH));\n\n        // Store context\n        this._context = context;\n    }\n\n    public get isEndOfMessage(): boolean {\n        return this._endOfMessage;\n    }\n\n    public get id(): number {\n        return this._id;\n    }\n\n    public get serial(): number {\n        return this._serial;\n    }\n\n    public get data(): Uint8Array {\n        return this._data;\n    }\n\n    public get context(): any {\n        return this._context;\n    }\n}\n\n/**\n * Helper class to hold chunks and an \"end-arrived\" flag.\n */\nclass ChunkCollector {\n    private endArrived: boolean;\n    private messageLength: number = null;\n    private chunks: Chunk[] = [];\n    private lastUpdate: number = new Date().getTime();\n\n    /**\n     * Register a new chunk. Return a boolean indicating whether the chunk was added.\n     */\n    public addChunk(chunk: Chunk): void {\n        // Ignore repeated chunks with the same serial\n        if (this.hasSerial(chunk.serial)) {\n            return;\n        }\n\n        // Add chunk\n        this.chunks.push(chunk);\n\n        // Process chunk\n        this.lastUpdate = new Date().getTime();\n        if (chunk.isEndOfMessage) {\n            this.endArrived = true;\n            this.messageLength = chunk.serial + 1;\n        }\n    }\n\n    /**\n     * Return whether this chunk collector already contains a chunk with the specified serial.\n     */\n    public hasSerial(serial: number): boolean {\n        return this.chunks.find(\n            (chunk: Chunk) => chunk.serial === serial,\n        ) !== undefined;\n    }\n\n    /**\n     * Return whether the message is complete, meaning that all chunks of the message arrived.\n     */\n    public get isComplete() {\n        return this.endArrived && this.chunks.length === this.messageLength;\n    }\n\n    /**\n     * Merge the messages.\n     *\n     * Note: This implementation assumes that no chunk will be larger than the first one!\n     * If this is not the case, an error may be thrown.\n     *\n     * @return An object containing the message as an `Uint8Array`\n     *         and a (possibly empty) list of context objects.\n     * @throws Error if message is not yet complete.\n     */\n    public merge(): {message: Uint8Array, context: any[]} {\n        // Preconditions\n        if (!this.isComplete) {\n            throw new Error('Not all chunks for this message have arrived yet.');\n        }\n\n        // Sort chunks\n        this.chunks.sort((a: Chunk, b: Chunk) => {\n            if (a.serial < b.serial) {\n                return -1;\n            } else if (a.serial > b.serial) {\n                return 1;\n            }\n            return 0;\n        });\n\n        // Allocate buffer\n        const capacity = this.chunks[0].data.byteLength * this.messageLength;\n        const buf = new Uint8Array(new ArrayBuffer(capacity));\n\n        // Add chunks to buffer\n        let offset = 0;\n        const firstSize = this.chunks[0].data.byteLength;\n        const contextList = [];\n        for (const chunk of this.chunks) {\n            if (chunk.data.byteLength > firstSize) {\n                throw new Error('No chunk may be larger than the first chunk of that message.');\n            }\n            buf.set(chunk.data, offset);\n            offset += chunk.data.length;\n            if (chunk.context !== undefined) {\n                contextList.push(chunk.context);\n            }\n        }\n\n        // Return result object\n        return {\n            message: buf.slice(0, offset),\n            context: contextList,\n        };\n    }\n\n    /**\n     * Return whether last chunk is older than the specified number of miliseconds.\n     */\n    public isOlderThan(maxAge: number): boolean {\n        const age = (new Date().getTime() - this.lastUpdate);\n        return age > maxAge;\n    }\n\n    /**\n     * Return the number of registered chunks.\n     */\n    public get chunkCount(): number {\n        return this.chunks.length;\n    }\n}\n\n/**\n * An Unchunker instance merges multiple chunks into a single Uint8Array.\n *\n * It keeps track of IDs, so only one Unchunker instance is necessary\n * to receive multiple messages.\n */\nexport class Unchunker {\n    private chunks: Map<number, ChunkCollector> = new Map();\n\n    /**\n     * Message listener. Set by the user.\n     */\n    public onMessage: (message: Uint8Array, context?: any[]) => void = null;\n\n    /**\n     * Add a chunk.\n     *\n     * @param buf ArrayBuffer containing chunk with 9 byte header.\n     * @param context Arbitrary data that will be registered with the chunk and will be passed to the callback.\n     * @throws Error if message is smaller than the header length.\n     */\n    public add(buf: ArrayBuffer, context?: any): void {\n        // Parse chunk\n        const chunk = new Chunk(buf, context);\n\n        // Ignore repeated chunks with the same serial\n        if (this.chunks.has(chunk.id) && this.chunks.get(chunk.id).hasSerial(chunk.serial)) {\n            return;\n        }\n\n        // If this is the only chunk in the message, return it immediately.\n        if (chunk.isEndOfMessage && chunk.serial === 0) {\n            this.notifyListener(chunk.data, context === undefined ? [] : [context]);\n            this.chunks.delete(chunk.id);\n            return;\n        }\n\n        // Otherwise, add chunk to chunks list\n        let collector: ChunkCollector;\n        if (this.chunks.has(chunk.id)) {\n            collector = this.chunks.get(chunk.id);\n        } else {\n            collector = new ChunkCollector();\n            this.chunks.set(chunk.id, collector);\n        }\n        collector.addChunk(chunk);\n\n        // Check if message is complete\n        if (collector.isComplete) {\n            // Merge and notify listener...\n            const merged = collector.merge();\n            this.notifyListener(merged.message, merged.context);\n            // ...then delete the chunks.\n            this.chunks.delete(chunk.id);\n        }\n    }\n\n    /**\n     * If a message listener is set, notify it about a complete message.\n     */\n    private notifyListener(message: Uint8Array, context: any[]) {\n        if (this.onMessage != null) {\n            this.onMessage(message, context);\n        }\n    }\n\n    /**\n     * Run garbage collection, remove incomplete messages that haven't been\n     * updated for more than the specified number of milliseconds.\n     *\n     * If you want to make sure that invalid chunks don't fill up memory, call\n     * this method regularly.\n     *\n     * @param maxAge Remove incomplete messages that haven't been updated for\n     *               more than the specified number of milliseconds.\n     * @return the number of removed chunks.\n     */\n    public gc(maxAge: number): number {\n        let removedItems = 0;\n        for (const entry of this.chunks) {\n            const msgId: number = entry[0];\n            const collector: ChunkCollector = entry[1];\n            if (collector.isOlderThan(maxAge)) {\n                removedItems += collector.chunkCount;\n                this.chunks.delete(msgId);\n            }\n        }\n        return removedItems;\n    }\n}\n","/**\n * Copyright (C) 2016-2018 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\nimport { Common } from './common';\n\n// Export classes\nexport { Chunker } from './chunker';\nexport { Unchunker } from './unchunker';\n\n// Export constants\nexport const HEADER_LENGTH = Common.HEADER_LENGTH;\n"],"names":[],"mappings":"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"}