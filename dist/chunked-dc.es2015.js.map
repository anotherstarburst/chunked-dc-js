{"version":3,"file":"chunked-dc.es2015.js","sources":["../src/common.ts","../src/chunker.ts","../src/unchunker.ts"],"sourcesContent":["/**\n * Copyright (C) 2016-2019 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\n\nexport const RELIABLE_ORDERED_HEADER_LENGTH = 1;\nexport const UNRELIABLE_UNORDERED_HEADER_LENGTH = 9;\n\n/**\n * The mode being used when chunking/unchunking.\n */\nexport const MODE_BITMASK = 6;\nexport const enum Mode {\n    // Important: Changes to the values must correspond to the options field!\n\n    // R R R R R 1 1 E\n    ReliableOrdered = 6,\n    // R R R R R 0 0 E\n    UnreliableUnordered = 0,\n}\n","/**\n * Copyright (C) 2016-2019 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\n/// <reference path='../chunked-dc.d.ts' />\n\nimport { Mode, RELIABLE_ORDERED_HEADER_LENGTH, UNRELIABLE_UNORDERED_HEADER_LENGTH } from './common';\n\n/**\n * A chunker fragments a single message into multiple chunks.\n *\n * For each message to be chunked, a new instance is required.\n */\nabstract class AbstractChunker implements chunkedDc.Chunker {\n    private readonly mode: Mode;\n    private readonly id: number | null;\n    private readonly message: Uint8Array;\n    private readonly headerLength: number;\n    private readonly payloadLength: number;\n    private readonly buffer: ArrayBuffer | null;\n    private offset: number = 0;\n    private serial: number = 0;\n\n    /**\n     * Create a chunker for a specific mode.\n     */\n    protected constructor(\n        mode: Mode, headerLength: number, id: number | null, message: Uint8Array, chunkLength: number,\n        buffer: ArrayBuffer = null,\n    ) {\n        const minChunkSize = headerLength + 1;\n        if (chunkLength < minChunkSize) {\n            throw new Error(`Chunk size must be at least ${minChunkSize}`);\n        }\n        if (buffer !== null && buffer.byteLength < chunkLength) {\n            throw new Error('Buffer too small for chunks');\n        }\n        if (message.byteLength < 1) {\n            throw new Error('Message may not be empty');\n        }\n        if (id != null && (id < 0 || id >= (2 ** 32))) {\n            throw new Error('Message id must be between 0 and 2**32-1');\n        }\n\n        this.mode = mode;\n        this.id = id;\n        this.message = message;\n        this.headerLength = headerLength;\n        this.payloadLength = chunkLength - headerLength;\n        this.buffer = buffer;\n    }\n\n    /**\n     * Whether there are more chunks available.\n     */\n    public get hasNext(): boolean {\n        return this.offset < this.message.byteLength;\n    }\n\n    /**\n     * Iterator implementation. Value is the next Uint8Array chunk.\n     *\n     * Important: When the chunker has been created with an `ArrayBuffer`,\n     *            the underlying buffer of the chunk will be reused in the next\n     *            iteration.\n     */\n    public next(): IteratorResult<Uint8Array> {\n        if (!this.hasNext) {\n            return {\n                done: true,\n                value: null,\n            };\n        }\n\n        // Allocate chunk buffer (if required)\n        const remaining = this.message.byteLength - this.offset;\n        const payloadLength = remaining < this.payloadLength ? remaining : this.payloadLength;\n        const chunkLength = this.headerLength + payloadLength;\n        const endOffset = this.offset + payloadLength;\n        let chunkBuffer: ArrayBuffer;\n        if (this.buffer !== null) {\n            chunkBuffer = this.buffer;\n        } else {\n            chunkBuffer = new ArrayBuffer(chunkLength);\n        }\n\n        // Set header\n        const chunkView = new DataView(chunkBuffer);\n        let options: number = this.mode;\n        if (endOffset === this.message.byteLength) {\n            options |= 1; // tslint:disable-line:no-bitwise\n        }\n        chunkView.setUint8(0, options);\n        switch (this.mode) {\n            case Mode.ReliableOrdered:\n                break;\n            case Mode.UnreliableUnordered:\n                chunkView.setUint32(1, this.id);\n                chunkView.setUint32(5, this.serial++);\n                break;\n        }\n\n        // Set payload\n        const payloadSlice = this.message.subarray(this.offset, endOffset);\n        const chunkArray = new Uint8Array(chunkBuffer, 0, chunkLength);\n        chunkArray.set(payloadSlice, this.headerLength);\n        this.offset = endOffset;\n        return {\n            done: false,\n            value: chunkArray,\n        };\n    }\n\n    /**\n     * Return an iterator over the chunks.\n     */\n    public [Symbol.iterator](): IterableIterator<Uint8Array> {\n        return this;\n    }\n}\n\nexport class ReliableOrderedChunker extends AbstractChunker implements chunkedDc.ReliableOrderedChunker {\n    /**\n     * Create a chunker for reliable & ordered mode.\n     *\n     * @param message The Uint8Array containing the bytes that should be chunked.\n     * @param chunkLength The chunk size *including* header data.\n     * @param buffer A chunk buffer to be used for handing out chunks. Must be\n     *   able to at least contain `chunkLength` bytes. A new buffer will be\n     *   created for every chunk if not supplied.\n     * @throws Error if a chunk would not fit into the specified chunk length,\n     *   if the message is empty, and if the message id is too large.\n     */\n    public constructor(message: Uint8Array, chunkLength: number, buffer?: ArrayBuffer) {\n        super(Mode.ReliableOrdered, RELIABLE_ORDERED_HEADER_LENGTH, null, message, chunkLength, buffer);\n    }\n}\n\nexport class UnreliableUnorderedChunker extends AbstractChunker implements chunkedDc.UnreliableUnorderedChunker {\n    /**\n     * Create a chunker for reliable & ordered mode.\n     *\n     * @param id An identifier for the message. Must be between 0 and 2**32-1.\n     * @param message The Uint8Array containing the bytes that should be chunked.\n     * @param chunkLength The chunk size *including* header data.\n     * @param buffer A chunk buffer to be used for handing out chunks. Must be\n     *   able to at least contain `chunkLength` bytes. A new buffer will be\n     *   created for every chunk if not supplied.\n     * @throws Error if a chunk would not fit into the specified chunk length,\n     *   if the message is empty, and if the message id is too large.\n     */\n    public constructor(id: number, message: Uint8Array, chunkLength: number, buffer?: ArrayBuffer) {\n        super(Mode.UnreliableUnordered, UNRELIABLE_UNORDERED_HEADER_LENGTH, id, message, chunkLength, buffer);\n    }\n}\n","/**\n * Copyright (C) 2016-2019 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\n/// <reference path='../chunked-dc.d.ts' />\n\nimport { Mode, MODE_BITMASK, RELIABLE_ORDERED_HEADER_LENGTH, UNRELIABLE_UNORDERED_HEADER_LENGTH } from './common';\n\n/**\n * Helper class to store chunk information.\n */\nexport class Chunk {\n    public readonly endOfMessage: boolean;\n    public readonly id: number;\n    public readonly serial: number;\n    public readonly payload: Uint8Array;\n\n    /**\n     * Parse the chunk.\n     *\n     * @param chunkArray The chunk's array which will be **referenced**.\n     * @param expectedMode The mode we expect the chunk to use.\n     * @param headerLength The expected header length.\n     * @throws Error if message is smaller than the header length or an unexpected mode has been detected.\n     */\n    public constructor(chunkArray: Uint8Array, expectedMode: Mode, headerLength: number) {\n        if (chunkArray.byteLength < headerLength) {\n            throw new Error('Invalid chunk: Too short');\n        }\n\n        // Read header\n        const chunkView = new DataView(chunkArray.buffer, chunkArray.byteOffset, chunkArray.byteLength);\n        const options = chunkView.getUint8(0);\n        const actualMode = (options & MODE_BITMASK); // tslint:disable-line:no-bitwise\n        if (actualMode !== expectedMode) {\n            throw new Error(`Invalid chunk: Unexpected mode ${actualMode}`);\n        }\n        switch (expectedMode) {\n            case Mode.ReliableOrdered:\n                break;\n            case Mode.UnreliableUnordered:\n                this.id = chunkView.getUint32(1);\n                this.serial = chunkView.getUint32(5);\n                break;\n        }\n        this.endOfMessage = (options & 1) === 1; // tslint:disable-line:no-bitwise\n\n        // Store payload\n        this.payload = chunkArray.subarray(headerLength);\n    }\n}\n\n/**\n * Copies chunks into a contiguous buffer.\n */\nclass ContiguousBufferReassembler {\n    private complete: boolean = false;\n    private buffer: ArrayBuffer | null;\n    private array: Uint8Array | null;\n    private offset: number;\n    private remaining: number;\n\n    /**\n     * Create a reassembler for reliable & ordered mode.\n     *\n     * @param buffer A message buffer to be used for handing out messages.\n     *   If the message grows larger than the underlying buffer, it will be\n     *   replaced. A new buffer will be created when needed if not supplied.\n     */\n    public constructor(buffer: ArrayBuffer | null = null) {\n        this.buffer = buffer;\n        if (this.buffer !== null) {\n            this.array = new Uint8Array(this.buffer);\n            this.offset = 0;\n            this.remaining = this.buffer.byteLength;\n        } else {\n            this.array = null;\n            this.offset = 0;\n            this.remaining = 0;\n        }\n    }\n\n    /**\n     * Return `true` in case nothing has been written to the reassembler, yet.\n     */\n    public get empty(): boolean {\n        return this.offset === 0;\n    }\n\n    /**\n     * Append a chunk to the internal buffer.\n     *\n     * Important: Do not mix chunks with different ids in the same reassembler\n     *            instance or it will break!\n     *\n     * @param chunk The chunk to be appended.\n     * @throws Error if the message is already complete.\n     */\n    public add(chunk: Chunk): void {\n        if (this.complete) {\n            throw new Error('Message already complete');\n        }\n        const chunkLength = chunk.payload.byteLength;\n        this.maybeResize(chunkLength);\n        this.complete = chunk.endOfMessage;\n        this.array.set(chunk.payload, this.offset);\n        this.offset += chunkLength;\n        this.remaining -= chunkLength;\n    }\n\n    /**\n     * Append a batch of chunks to the internal buffer.\n     *\n     * Important: Do not mix chunks with different ids in the same reassembler\n     *            instance or it will break!\n     *\n     * @param chunks The chunks to be appended.\n     * @param totalByteLength The accumulated byte length of the chunks.\n     * @return the last chunk that has been added.\n     * @throws Error if the message is already complete.\n     */\n    public addBatched(chunks: Chunk[], totalByteLength: number): Chunk {\n        this.maybeResize(totalByteLength);\n        let chunk: Chunk;\n        for (chunk of chunks) {\n            if (this.complete) {\n                throw new Error('Message already complete');\n            }\n            this.complete = chunk.endOfMessage;\n            this.array.set(chunk.payload, this.offset);\n            this.offset += chunk.payload.byteLength;\n        }\n        this.remaining -= totalByteLength;\n        return chunk;\n    }\n\n    /**\n     * Prepare the internal buffer so one or more new chunks can be safely\n     * added.\n     *\n     * Note: We apply a heuristic here to double the buffer's size, so we don't\n     *       need to create new buffers and copy every time. This should be\n     *       faster than merging at the end since we can expect that the local\n     *       machine copies memory faster than it will receive new chunks.\n     *\n     * @param requiredLength The required byte length.\n     */\n    private maybeResize(requiredLength: number): void {\n        // We have no underlying buffer - allocate it directly for the required size\n        if (this.buffer === null) {\n            this.buffer = new ArrayBuffer(requiredLength);\n            this.array = new Uint8Array(this.buffer);\n            return;\n        }\n\n        // Reallocate the underlying buffer if needed\n        if (this.remaining < requiredLength) {\n            const previousArray = this.array;\n            const length = Math.max(previousArray.byteLength * 2, previousArray.byteLength + requiredLength);\n            this.buffer = new ArrayBuffer(length);\n            this.array = new Uint8Array(this.buffer);\n            this.array.set(previousArray);\n            this.remaining = length - this.offset;\n        }\n    }\n\n    /**\n     * Extract the complete message from the internal buffer as a view.\n     *\n     * Important: The returned message's underlying buffer will be reused with\n     *            the next chunk being reassembled.\n     *\n     * @return The completed message.\n     * @throws Error if the message is not yet complete.\n     */\n    public getMessage(): Uint8Array {\n        if (!this.complete) {\n            throw new Error('Message not complete');\n        }\n        const message = this.array.subarray(0, this.offset);\n        this.complete = false;\n        this.offset = 0;\n        this.remaining = this.buffer.byteLength;\n        return message;\n    }\n}\n\n/**\n * Reorders chunks and then copies them into a contiguous buffer.\n */\nclass UnreliableUnorderedReassembler {\n    private readonly contiguousChunks: ContiguousBufferReassembler = new ContiguousBufferReassembler();\n    private queuedChunks: Chunk[] | null = null;\n    private queuedChunksTotalByteLength: number = 0;\n    private _chunkCount: number = 0;\n    private nextOrderedSerial: number = 0;\n    private lastUpdate: number = new Date().getTime();\n    private requiredChunkCount: number | null = null;\n\n    /**\n     * Return the number of added chunks.\n     */\n    public get chunkCount(): number {\n        return this._chunkCount;\n    }\n\n    /**\n     * Return whether the message is complete, meaning that all chunks of the message arrived.\n     */\n    public get complete() {\n        return this.requiredChunkCount !== null && this._chunkCount === this.requiredChunkCount;\n    }\n\n    /**\n     * Add a new chunk.\n     *\n     * Important: Do not mix chunks with different ids in the same reassembler\n     *            instance or it will break!\n     *\n     * @throws Error if the message is already complete.\n     */\n    public add(chunk: Chunk): void {\n        // Already complete?\n        if (this.complete) {\n            throw new Error('Message already complete');\n        }\n\n        if (this.queuedChunks === null && chunk.serial === this._chunkCount) {\n            // In order: Can be added to the contiguous chunks\n            this.contiguousChunks.add(chunk);\n            this.nextOrderedSerial = chunk.serial + 1;\n        } else {\n            // Out of order: Needs to be temporarily stored in a queue\n            const ready = this.queueUnorderedChunk(chunk);\n            if (ready) {\n                // Queue is ready to be moved into the contiguous buffer.\n                this.moveQueuedChunks();\n            }\n        }\n\n        // Check if this is the last chunk received\n        if (chunk.endOfMessage) {\n            this.requiredChunkCount = chunk.serial + 1;\n        }\n\n        // Update chunk counter and timestamp\n        ++this._chunkCount;\n        this.lastUpdate = new Date().getTime();\n    }\n\n    /**\n     * Add a new chunk to its intended position in the out-of-order queue.\n     *\n     * Note: We continuously sort the queue by the serial number (ascending).\n     *\n     * @returns whether the queue is ready to be moved into the contiguous buffer.\n     */\n    private queueUnorderedChunk(chunk: Chunk): boolean {\n        // Append chunk\n        this.queuedChunksTotalByteLength += chunk.payload.byteLength;\n        if (this.queuedChunks === null) {\n            this.queuedChunks = [chunk];\n            return false;\n        }\n        this.queuedChunks.push(chunk);\n\n        // Sort chunk queue\n        this.queuedChunks.sort((a: Chunk, b: Chunk) => {\n            if (a.serial < b.serial) {\n                return -1;\n            }\n            if (a.serial > b.serial) {\n                return 1;\n            }\n            return 0;\n        });\n\n        // Check if ready\n        const iterator = this.queuedChunks.values();\n        let previousChunk = iterator.next().value;\n        if (previousChunk.serial !== this.nextOrderedSerial) {\n            return false;\n        }\n        for (const currentChunk of iterator) {\n            if (previousChunk.serial + 1 !== currentChunk.serial) {\n                return false;\n            }\n            previousChunk = currentChunk;\n        }\n        return true;\n    }\n\n    /**\n     * Moves the queued chunks to the contiguous buffer.\n     *\n     * Should be called once the queue contains consecutive chunks and there is\n     * no gap between the contiguous chunk buffer and our queued chunks.\n     */\n    private moveQueuedChunks(): void {\n        const chunk = this.contiguousChunks.addBatched(this.queuedChunks, this.queuedChunksTotalByteLength);\n        // Note: `chunk` is the last chunk in the sequence and has the highest serial number\n        this.nextOrderedSerial = chunk.serial + 1;\n        this.queuedChunks = null;\n    }\n\n    /**\n     * Get the reassembled message.\n     *\n     * @return The completed message.\n     * @throws Error if the message is not yet complete.\n     */\n    public getMessage(): Uint8Array {\n        if (!this.complete) {\n            throw new Error('Message not complete');\n        }\n        return this.contiguousChunks.getMessage();\n    }\n\n    /**\n     * Return whether last chunk is older than the specified number of milliseconds.\n     */\n    public isOlderThan(maxAge: number): boolean {\n        const age = (new Date().getTime() - this.lastUpdate);\n        return age > maxAge;\n    }\n}\n\n/**\n * An unchunker reassembles multiple chunks into a single message.\n */\nabstract class AbstractUnchunker implements chunkedDc.Unchunker {\n    /**\n     * Message listener. Set by the user.\n     *\n     * Important: The passed message's underlying buffer will be reused with\n     *            the next chunk being reassembled.\n     */\n    public onMessage: (message: Uint8Array) => void = null;\n\n    /**\n     * Notify message listener about a complete message.\n     */\n    protected notifyListener(message: Uint8Array) {\n        if (this.onMessage != null) {\n            this.onMessage(message);\n        }\n    }\n\n    /**\n     * Add a chunk.\n     *\n     * @param chunkArray A chunk containing either a 1 byte or 9 byte header.\n     *   Important: The chunk's underlying buffer should be considered transferred!\n     * @throws Error if message is smaller than the header length or an unknown\n     *   mode has been detected.\n     */\n    public abstract add(chunkArray: Uint8Array): void;\n}\n\n/**\n * An unchunker for reliable & ordered mode.\n */\nexport class ReliableOrderedUnchunker extends AbstractUnchunker implements chunkedDc.ReliableOrderedUnchunker {\n    private readonly reassembler: ContiguousBufferReassembler;\n\n    /**\n     * Create an unchunker for reliable & ordered mode.\n     *\n     * @param buffer A message buffer to be used for handing out messages.\n     *   If the message grows larger than the underlying buffer, it will be\n     *   replaced. A new buffer will be created when needed if not supplied.\n     */\n    public constructor(buffer?: ArrayBuffer) {\n        super();\n        this.reassembler = new ContiguousBufferReassembler(buffer);\n    }\n\n    /**\n     * Add a chunk.\n     *\n     * @param chunkArray A chunk containing a 1 byte header.\n     *   Important: The chunk's underlying buffer should be considered transferred!\n     * @throws Error if message is smaller than the header length or an unknown\n     *   mode has been detected.\n     */\n    public add(chunkArray: Uint8Array): void {\n        // Parse chunk\n        const chunk = new Chunk(chunkArray, Mode.ReliableOrdered, RELIABLE_ORDERED_HEADER_LENGTH);\n\n        // If this is a single chunk that contains the whole message, return it immediately.\n        if (this.reassembler.empty && chunk.endOfMessage) {\n            this.notifyListener(chunk.payload);\n            return;\n        }\n\n        // Add the chunk's payload to the message buffer.\n        this.reassembler.add(chunk);\n\n        // Check if message is complete\n        if (chunk.endOfMessage) {\n            // Hand out the message and reset the buffer\n            this.notifyListener(this.reassembler.getMessage());\n        }\n    }\n}\n\n/**\n * A reassembler optimised for unreliable & unordered mode.\n */\nexport class UnreliableUnorderedUnchunker extends AbstractUnchunker implements chunkedDc.UnreliableUnorderedUnchunker {\n    private reassemblers: Map<number, UnreliableUnorderedReassembler> = new Map();\n\n    /**\n     * Add a chunk.\n     *\n     * @param chunkArray A chunk containing a 9 byte header.\n     *   Important: The chunk's underlying buffer should be considered transferred!\n     * @throws Error if message is smaller than the header length or an unknown\n     *   mode has been detected.\n     */\n    public add(chunkArray: Uint8Array): void {\n        // Parse chunk\n        const chunk = new Chunk(chunkArray, Mode.UnreliableUnordered, UNRELIABLE_UNORDERED_HEADER_LENGTH);\n\n        // If this is a single chunk that contains the whole message, return it immediately.\n        if (chunk.endOfMessage && chunk.serial === 0) {\n            this.notifyListener(chunk.payload);\n            return;\n        }\n\n        // Add chunk to reassembler\n        let reassembler: UnreliableUnorderedReassembler = this.reassemblers.get(chunk.id);\n        if (reassembler === undefined) {\n            reassembler = new UnreliableUnorderedReassembler();\n            this.reassemblers.set(chunk.id, reassembler);\n        }\n        reassembler.add(chunk);\n\n        // Check if message is complete\n        if (reassembler.complete) {\n            // Hand out the message and delete the message's reassembler\n            this.notifyListener(reassembler.getMessage());\n            this.reassemblers.delete(chunk.id);\n        }\n    }\n\n    /**\n     * Run garbage collection, remove incomplete messages that haven't been\n     * updated for more than the specified number of milliseconds.\n     *\n     * If you want to make sure that invalid chunks don't fill up memory, call\n     * this method regularly.\n     *\n     * @param maxAge Remove incomplete messages that haven't been updated for\n     *               more than the specified number of milliseconds.\n     */\n    public gc(maxAge: number): number {\n        let removed = 0;\n        for (const [id, reassembler] of this.reassemblers) {\n            if (reassembler.isOlderThan(maxAge)) {\n                removed += reassembler.chunkCount;\n                this.reassemblers.delete(id);\n            }\n        }\n        return removed;\n    }\n}\n"],"names":[],"mappings":"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"}