{"version":3,"file":"chunked-dc.es5.min.js","sources":["../src/common.ts","../src/chunker.ts","../src/unchunker.ts","../src/main.ts"],"sourcesContent":["/**\n * Copyright (C) 2016-2018 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\nexport class Common {\n    public static HEADER_LENGTH = 9;\n}\n","/**\n * Copyright (C) 2016-2018 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\n/// <reference path='../chunked-dc.d.ts' />\n\nimport { Common } from './common';\n\n/**\n * A Chunker instance splits up an Uint8Array into multiple chunks.\n *\n * The Chunker is initialized with an ID. For each message to be chunked,\n * a new Chunker instance is required.\n */\nexport class Chunker implements chunkedDc.Chunker {\n\n    private id: number;\n    private chunkDataSize: number;\n    private chunkId: number = 0;\n    private message: Uint8Array;\n\n    /**\n     * Create a Chunker instance.\n     *\n     * @param id An identifier for the message. Must be between 0 and 2**32-1.\n     * @param message The Uint8Array containing the bytes that should be chunked.\n     * @param chunkSize The chunk size *including* header data.\n     */\n    constructor(id: number, message: Uint8Array, chunkSize: number) {\n        if (chunkSize < (Common.HEADER_LENGTH + 1)) {\n            throw new Error('Chunk size must be at least ' + (Common.HEADER_LENGTH + 1));\n        }\n        if (message.byteLength < 1) {\n            throw new Error('Array may not be empty');\n        }\n        if (id < 0 || id >= (2 ** 32)) {\n            throw new Error('Message id must be between 0 and 2**32-1');\n        }\n        this.id = id;\n        this.message = message;\n        this.chunkDataSize = chunkSize - Common.HEADER_LENGTH;\n    }\n\n    /**\n     * Whether there are more chunks available.\n     */\n    public get hasNext(): boolean {\n        const currentIndex = this.chunkId * this.chunkDataSize;\n        const remaining = this.message.byteLength - currentIndex;\n        return remaining >= 1;\n    }\n\n    /**\n     * Iterator implementation. Value is the next Uint8Array chunk.\n     */\n    public next(): IteratorResult<Uint8Array> {\n        if (!this.hasNext) {\n            return {\n                done: true,\n                value: null,\n            };\n        }\n\n        // Allocate chunk buffer\n        const currentIndex = this.chunkId * this.chunkDataSize;\n        const remaining = this.message.byteLength - currentIndex;\n        const chunkBytes = remaining < this.chunkDataSize ? remaining : this.chunkDataSize;\n        const chunk = new DataView(new ArrayBuffer(chunkBytes + Common.HEADER_LENGTH));\n\n        // Create header\n        const options = remaining > chunkBytes ? 0 : 1;\n        const id = this.id;\n        const serial = this.nextSerial();\n\n        // Write to chunk buffer\n        chunk.setUint8(0, options);\n        chunk.setUint32(1, id);\n        chunk.setUint32(5, serial);\n        for (let i = 0; i < chunkBytes; i++) {\n            const offset = Common.HEADER_LENGTH + i;\n            chunk.setUint8(offset, this.message[currentIndex + i]);\n        }\n        return {\n            done: false,\n            value: new Uint8Array(chunk.buffer),\n        };\n    }\n\n    /**\n     * Return and post-increment the id of the next block\n     */\n    private nextSerial(): number {\n        return this.chunkId++;\n    }\n\n    /**\n     * Return an iterator over the chunks.\n     */\n    public [Symbol.iterator](): IterableIterator<Uint8Array> {\n        return this;\n    }\n\n}\n","/**\n * Copyright (C) 2016-2018 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\n/// <reference path='../chunked-dc.d.ts' />\n\nimport { Common } from './common';\n\n/**\n * Helper class to access chunk information.\n */\nexport class Chunk {\n    private _endOfMessage: boolean;\n    private _id: number;\n    private _serial: number;\n    private _data: Uint8Array;\n    private _context: any;\n\n    /**\n     * Parse the ArrayBuffer.\n     */\n    constructor(buf: ArrayBuffer, context?: any) {\n        if (buf.byteLength < Common.HEADER_LENGTH) {\n            throw new Error('Invalid chunk: Too short');\n        }\n\n        // Read header\n        const reader = new DataView(buf);\n        const options = reader.getUint8(0);\n        // tslint:disable-next-line:no-bitwise\n        this._endOfMessage = (options & 0x01) === 1;\n        this._id = reader.getUint32(1);\n        this._serial = reader.getUint32(5);\n\n        // Read data\n        // Note: We copy the data bytes instead of getting a reference to a subset of the buffer.\n        // This is less ideal for performance, but avoids bugs that can occur\n        // by 3rd party modification of the ArrayBuffer.\n        this._data = new Uint8Array(buf.slice(Common.HEADER_LENGTH));\n\n        // Store context\n        this._context = context;\n    }\n\n    public get isEndOfMessage(): boolean {\n        return this._endOfMessage;\n    }\n\n    public get id(): number {\n        return this._id;\n    }\n\n    public get serial(): number {\n        return this._serial;\n    }\n\n    public get data(): Uint8Array {\n        return this._data;\n    }\n\n    public get context(): any {\n        return this._context;\n    }\n}\n\n/**\n * Helper class to hold chunks and an \"end-arrived\" flag.\n */\nclass ChunkCollector {\n    private endArrived: boolean;\n    private messageLength: number = null;\n    private chunks: Chunk[] = [];\n    private lastUpdate: number = new Date().getTime();\n\n    /**\n     * Register a new chunk. Return a boolean indicating whether the chunk was added.\n     */\n    public addChunk(chunk: Chunk): void {\n        // Ignore repeated chunks with the same serial\n        if (this.hasSerial(chunk.serial)) {\n            return;\n        }\n\n        // Add chunk\n        this.chunks.push(chunk);\n\n        // Process chunk\n        this.lastUpdate = new Date().getTime();\n        if (chunk.isEndOfMessage) {\n            this.endArrived = true;\n            this.messageLength = chunk.serial + 1;\n        }\n    }\n\n    /**\n     * Return whether this chunk collector already contains a chunk with the specified serial.\n     */\n    public hasSerial(serial: number): boolean {\n        return this.chunks.find(\n            (chunk: Chunk) => chunk.serial === serial,\n        ) !== undefined;\n    }\n\n    /**\n     * Return whether the message is complete, meaning that all chunks of the message arrived.\n     */\n    public get isComplete() {\n        return this.endArrived && this.chunks.length === this.messageLength;\n    }\n\n    /**\n     * Merge the messages.\n     *\n     * Note: This implementation assumes that no chunk will be larger than the first one!\n     * If this is not the case, an error may be thrown.\n     *\n     * @return An object containing the message as an `Uint8Array`\n     *         and a (possibly empty) list of context objects.\n     * @throws Error if message is not yet complete.\n     */\n    public merge(): {message: Uint8Array, context: any[]} {\n        // Preconditions\n        if (!this.isComplete) {\n            throw new Error('Not all chunks for this message have arrived yet.');\n        }\n\n        // Sort chunks\n        this.chunks.sort((a: Chunk, b: Chunk) => {\n            if (a.serial < b.serial) {\n                return -1;\n            } else if (a.serial > b.serial) {\n                return 1;\n            }\n            return 0;\n        });\n\n        // Allocate buffer\n        const capacity = this.chunks[0].data.byteLength * this.messageLength;\n        const buf = new Uint8Array(new ArrayBuffer(capacity));\n\n        // Add chunks to buffer\n        let offset = 0;\n        const firstSize = this.chunks[0].data.byteLength;\n        const contextList = [];\n        for (const chunk of this.chunks) {\n            if (chunk.data.byteLength > firstSize) {\n                throw new Error('No chunk may be larger than the first chunk of that message.');\n            }\n            buf.set(chunk.data, offset);\n            offset += chunk.data.length;\n            if (chunk.context !== undefined) {\n                contextList.push(chunk.context);\n            }\n        }\n\n        // Return result object\n        return {\n            message: buf.slice(0, offset),\n            context: contextList,\n        };\n    }\n\n    /**\n     * Return whether last chunk is older than the specified number of miliseconds.\n     */\n    public isOlderThan(maxAge: number): boolean {\n        const age = (new Date().getTime() - this.lastUpdate);\n        return age > maxAge;\n    }\n\n    /**\n     * Return the number of registered chunks.\n     */\n    public get chunkCount(): number {\n        return this.chunks.length;\n    }\n}\n\n/**\n * An Unchunker instance merges multiple chunks into a single Uint8Array.\n *\n * It keeps track of IDs, so only one Unchunker instance is necessary\n * to receive multiple messages.\n */\nexport class Unchunker {\n    private chunks: Map<number, ChunkCollector> = new Map();\n\n    /**\n     * Message listener. Set by the user.\n     */\n    public onMessage: (message: Uint8Array, context?: any[]) => void = null;\n\n    /**\n     * Add a chunk.\n     *\n     * @param buf ArrayBuffer containing chunk with 9 byte header.\n     * @param context Arbitrary data that will be registered with the chunk and will be passed to the callback.\n     * @throws Error if message is smaller than the header length.\n     */\n    public add(buf: ArrayBuffer, context?: any): void {\n        // Parse chunk\n        const chunk = new Chunk(buf, context);\n\n        // Ignore repeated chunks with the same serial\n        if (this.chunks.has(chunk.id) && this.chunks.get(chunk.id).hasSerial(chunk.serial)) {\n            return;\n        }\n\n        // If this is the only chunk in the message, return it immediately.\n        if (chunk.isEndOfMessage && chunk.serial === 0) {\n            this.notifyListener(chunk.data, context === undefined ? [] : [context]);\n            this.chunks.delete(chunk.id);\n            return;\n        }\n\n        // Otherwise, add chunk to chunks list\n        let collector: ChunkCollector;\n        if (this.chunks.has(chunk.id)) {\n            collector = this.chunks.get(chunk.id);\n        } else {\n            collector = new ChunkCollector();\n            this.chunks.set(chunk.id, collector);\n        }\n        collector.addChunk(chunk);\n\n        // Check if message is complete\n        if (collector.isComplete) {\n            // Merge and notify listener...\n            const merged = collector.merge();\n            this.notifyListener(merged.message, merged.context);\n            // ...then delete the chunks.\n            this.chunks.delete(chunk.id);\n        }\n    }\n\n    /**\n     * If a message listener is set, notify it about a complete message.\n     */\n    private notifyListener(message: Uint8Array, context: any[]) {\n        if (this.onMessage != null) {\n            this.onMessage(message, context);\n        }\n    }\n\n    /**\n     * Run garbage collection, remove incomplete messages that haven't been\n     * updated for more than the specified number of milliseconds.\n     *\n     * If you want to make sure that invalid chunks don't fill up memory, call\n     * this method regularly.\n     *\n     * @param maxAge Remove incomplete messages that haven't been updated for\n     *               more than the specified number of milliseconds.\n     * @return the number of removed chunks.\n     */\n    public gc(maxAge: number): number {\n        let removedItems = 0;\n        for (const entry of this.chunks) {\n            const msgId: number = entry[0];\n            const collector: ChunkCollector = entry[1];\n            if (collector.isOlderThan(maxAge)) {\n                removedItems += collector.chunkCount;\n                this.chunks.delete(msgId);\n            }\n        }\n        return removedItems;\n    }\n}\n","/**\n * Copyright (C) 2016-2018 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\nimport { Common } from './common';\n\n// Export classes\nexport { Chunker } from './chunker';\nexport { Unchunker } from './unchunker';\n\n// Export constants\nexport const HEADER_LENGTH = Common.HEADER_LENGTH;\n"],"names":["Common","id","message","chunkSize","HEADER_LENGTH","Error","byteLength","Math","chunkDataSize","this","hasNext","currentIndex","chunkId","remaining","chunkBytes","chunk","DataView","ArrayBuffer","options","serial","nextSerial","setUint8","setUint32","i","offset","Uint8Array","buffer","Symbol","iterator","buf","context","reader","getUint8","_endOfMessage","_id","getUint32","_serial","_data","slice","_context","Date","getTime","hasSerial","chunks","push","lastUpdate","isEndOfMessage","endArrived","messageLength","undefined","find","isComplete","sort","a","b","capacity","data","firstSize","contextList","set","length","maxAge","Map","Chunk","has","get","notifyListener","delete","collector","ChunkCollector","addChunk","merged","merge","onMessage","removedItems","entry","msgId","isOlderThan","chunkCount"],"mappings":"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"}