{"version":3,"file":"chunked-dc.es5.min.js","sources":["../src/common.ts","../src/chunker.ts","../src/unchunker.ts"],"sourcesContent":["/**\n * Copyright (C) 2016-2019 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\n\nexport const RELIABLE_ORDERED_HEADER_LENGTH = 1;\nexport const UNRELIABLE_UNORDERED_HEADER_LENGTH = 9;\n\n/**\n * The mode being used when chunking/unchunking.\n */\nexport const MODE_BITMASK = 6;\nexport const enum Mode {\n    // Important: Changes to the values must correspond to the options field!\n\n    // R R R R R 1 1 E\n    ReliableOrdered = 6,\n    // R R R R R 0 0 E\n    UnreliableUnordered = 0,\n}\n","/**\n * Copyright (C) 2016-2019 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\n/// <reference path='../chunked-dc.d.ts' />\n\nimport { Mode, RELIABLE_ORDERED_HEADER_LENGTH, UNRELIABLE_UNORDERED_HEADER_LENGTH } from './common';\n\n/**\n * A chunker fragments a single message into multiple chunks.\n *\n * For each message to be chunked, a new instance is required.\n */\nabstract class AbstractChunker implements chunkedDc.Chunker {\n    private readonly mode: Mode;\n    private readonly id: number | null;\n    private readonly message: Uint8Array;\n    private readonly headerLength: number;\n    private readonly payloadLength: number;\n    private readonly buffer: ArrayBuffer | null;\n    private offset: number = 0;\n    private serial: number = 0;\n\n    /**\n     * Create a chunker for a specific mode.\n     */\n    protected constructor(\n        mode: Mode, headerLength: number, id: number | null, message: Uint8Array, chunkLength: number,\n        buffer: ArrayBuffer = null,\n    ) {\n        const minChunkSize = headerLength + 1;\n        if (chunkLength < minChunkSize) {\n            throw new Error(`Chunk size must be at least ${minChunkSize}`);\n        }\n        if (buffer !== null && buffer.byteLength < chunkLength) {\n            throw new Error('Buffer too small for chunks');\n        }\n        if (message.byteLength < 1) {\n            throw new Error('Message may not be empty');\n        }\n        if (id != null && (id < 0 || id >= (2 ** 32))) {\n            throw new Error('Message id must be between 0 and 2**32-1');\n        }\n\n        this.mode = mode;\n        this.id = id;\n        this.message = message;\n        this.headerLength = headerLength;\n        this.payloadLength = chunkLength - headerLength;\n        this.buffer = buffer;\n    }\n\n    /**\n     * Whether there are more chunks available.\n     */\n    public get hasNext(): boolean {\n        return this.offset < this.message.byteLength;\n    }\n\n    /**\n     * Iterator implementation. Value is the next Uint8Array chunk.\n     *\n     * Important: When the chunker has been created with an `ArrayBuffer`,\n     *            the underlying buffer of the chunk will be reused in the next\n     *            iteration.\n     */\n    public next(): IteratorResult<Uint8Array> {\n        if (!this.hasNext) {\n            return {\n                done: true,\n                value: null,\n            };\n        }\n\n        // Allocate chunk buffer (if required)\n        const remaining = this.message.byteLength - this.offset;\n        const payloadLength = remaining < this.payloadLength ? remaining : this.payloadLength;\n        const chunkLength = this.headerLength + payloadLength;\n        const endOffset = this.offset + payloadLength;\n        let chunkBuffer: ArrayBuffer;\n        if (this.buffer !== null) {\n            chunkBuffer = this.buffer;\n        } else {\n            chunkBuffer = new ArrayBuffer(chunkLength);\n        }\n\n        // Set header\n        const chunkView = new DataView(chunkBuffer);\n        let options: number = this.mode;\n        if (endOffset === this.message.byteLength) {\n            options |= 1; // tslint:disable-line:no-bitwise\n        }\n        chunkView.setUint8(0, options);\n        switch (this.mode) {\n            case Mode.ReliableOrdered:\n                break;\n            case Mode.UnreliableUnordered:\n                chunkView.setUint32(1, this.id);\n                chunkView.setUint32(5, this.serial++);\n                break;\n        }\n\n        // Set payload\n        const payloadSlice = this.message.subarray(this.offset, endOffset);\n        const chunkArray = new Uint8Array(chunkBuffer, 0, chunkLength);\n        chunkArray.set(payloadSlice, this.headerLength);\n        this.offset = endOffset;\n        return {\n            done: false,\n            value: chunkArray,\n        };\n    }\n\n    /**\n     * Return an iterator over the chunks.\n     */\n    public [Symbol.iterator](): IterableIterator<Uint8Array> {\n        return this;\n    }\n}\n\nexport class ReliableOrderedChunker extends AbstractChunker implements chunkedDc.ReliableOrderedChunker {\n    /**\n     * Create a chunker for reliable & ordered mode.\n     *\n     * @param message The Uint8Array containing the bytes that should be chunked.\n     * @param chunkLength The chunk size *including* header data.\n     * @param buffer A chunk buffer to be used for handing out chunks. Must be\n     *   able to at least contain `chunkLength` bytes. A new buffer will be\n     *   created for every chunk if not supplied.\n     * @throws Error if a chunk would not fit into the specified chunk length,\n     *   if the message is empty, and if the message id is too large.\n     */\n    public constructor(message: Uint8Array, chunkLength: number, buffer?: ArrayBuffer) {\n        super(Mode.ReliableOrdered, RELIABLE_ORDERED_HEADER_LENGTH, null, message, chunkLength, buffer);\n    }\n}\n\nexport class UnreliableUnorderedChunker extends AbstractChunker implements chunkedDc.UnreliableUnorderedChunker {\n    /**\n     * Create a chunker for reliable & ordered mode.\n     *\n     * @param id An identifier for the message. Must be between 0 and 2**32-1.\n     * @param message The Uint8Array containing the bytes that should be chunked.\n     * @param chunkLength The chunk size *including* header data.\n     * @param buffer A chunk buffer to be used for handing out chunks. Must be\n     *   able to at least contain `chunkLength` bytes. A new buffer will be\n     *   created for every chunk if not supplied.\n     * @throws Error if a chunk would not fit into the specified chunk length,\n     *   if the message is empty, and if the message id is too large.\n     */\n    public constructor(id: number, message: Uint8Array, chunkLength: number, buffer?: ArrayBuffer) {\n        super(Mode.UnreliableUnordered, UNRELIABLE_UNORDERED_HEADER_LENGTH, id, message, chunkLength, buffer);\n    }\n}\n","/**\n * Copyright (C) 2016-2019 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\n/// <reference path='../chunked-dc.d.ts' />\n\nimport { Mode, MODE_BITMASK, RELIABLE_ORDERED_HEADER_LENGTH, UNRELIABLE_UNORDERED_HEADER_LENGTH } from './common';\n\n/**\n * Helper class to store chunk information.\n */\nexport class Chunk {\n    public readonly endOfMessage: boolean;\n    public readonly id: number;\n    public readonly serial: number;\n    public readonly payload: Uint8Array;\n\n    /**\n     * Parse the chunk.\n     *\n     * @param chunkArray The chunk's array which will be **referenced**.\n     * @param expectedMode The mode we expect the chunk to use.\n     * @param headerLength The expected header length.\n     * @throws Error if message is smaller than the header length or an unexpected mode has been detected.\n     */\n    public constructor(chunkArray: Uint8Array, expectedMode: Mode, headerLength: number) {\n        if (chunkArray.byteLength < headerLength) {\n            throw new Error('Invalid chunk: Too short');\n        }\n\n        // Read header\n        const chunkView = new DataView(chunkArray.buffer, chunkArray.byteOffset, chunkArray.byteLength);\n        const options = chunkView.getUint8(0);\n        const actualMode = (options & MODE_BITMASK); // tslint:disable-line:no-bitwise\n        if (actualMode !== expectedMode) {\n            throw new Error(`Invalid chunk: Unexpected mode ${actualMode}`);\n        }\n        switch (expectedMode) {\n            case Mode.ReliableOrdered:\n                break;\n            case Mode.UnreliableUnordered:\n                this.id = chunkView.getUint32(1);\n                this.serial = chunkView.getUint32(5);\n                break;\n        }\n        this.endOfMessage = (options & 1) === 1; // tslint:disable-line:no-bitwise\n\n        // Store payload\n        this.payload = chunkArray.subarray(headerLength);\n    }\n}\n\n/**\n * Copies chunks into a contiguous buffer.\n */\nclass ContiguousBufferReassembler {\n    private complete: boolean = false;\n    private buffer: ArrayBuffer | null;\n    private array: Uint8Array | null;\n    private offset: number;\n    private remaining: number;\n\n    /**\n     * Create a reassembler for reliable & ordered mode.\n     *\n     * @param buffer A message buffer to be used for handing out messages.\n     *   If the message grows larger than the underlying buffer, it will be\n     *   replaced. A new buffer will be created when needed if not supplied.\n     */\n    public constructor(buffer: ArrayBuffer | null = null) {\n        this.buffer = buffer;\n        if (this.buffer !== null) {\n            this.array = new Uint8Array(this.buffer);\n            this.offset = 0;\n            this.remaining = this.buffer.byteLength;\n        } else {\n            this.array = null;\n            this.offset = 0;\n            this.remaining = 0;\n        }\n    }\n\n    /**\n     * Return `true` in case nothing has been written to the reassembler, yet.\n     */\n    public get empty(): boolean {\n        return this.offset === 0;\n    }\n\n    /**\n     * Append a chunk to the internal buffer.\n     *\n     * Important: Do not mix chunks with different ids in the same reassembler\n     *            instance or it will break!\n     *\n     * @param chunk The chunk to be appended.\n     * @throws Error if the message is already complete.\n     */\n    public add(chunk: Chunk): void {\n        if (this.complete) {\n            throw new Error('Message already complete');\n        }\n        const chunkLength = chunk.payload.byteLength;\n        this.maybeResize(chunkLength);\n        this.complete = chunk.endOfMessage;\n        this.array.set(chunk.payload, this.offset);\n        this.offset += chunkLength;\n        this.remaining -= chunkLength;\n    }\n\n    /**\n     * Append a batch of chunks to the internal buffer.\n     *\n     * Important: Do not mix chunks with different ids in the same reassembler\n     *            instance or it will break!\n     *\n     * @param chunks The chunks to be appended.\n     * @param totalByteLength The accumulated byte length of the chunks.\n     * @return the last chunk that has been added.\n     * @throws Error if the message is already complete.\n     */\n    public addBatched(chunks: Chunk[], totalByteLength: number): Chunk {\n        this.maybeResize(totalByteLength);\n        let chunk: Chunk;\n        for (chunk of chunks) {\n            if (this.complete) {\n                throw new Error('Message already complete');\n            }\n            this.complete = chunk.endOfMessage;\n            this.array.set(chunk.payload, this.offset);\n            this.offset += chunk.payload.byteLength;\n        }\n        this.remaining -= totalByteLength;\n        return chunk;\n    }\n\n    /**\n     * Prepare the internal buffer so one or more new chunks can be safely\n     * added.\n     *\n     * Note: We apply a heuristic here to double the buffer's size, so we don't\n     *       need to create new buffers and copy every time. This should be\n     *       faster than merging at the end since we can expect that the local\n     *       machine copies memory faster than it will receive new chunks.\n     *\n     * @param requiredLength The required byte length.\n     */\n    private maybeResize(requiredLength: number): void {\n        // We have no underlying buffer - allocate it directly for the required size\n        if (this.buffer === null) {\n            this.buffer = new ArrayBuffer(requiredLength);\n            this.array = new Uint8Array(this.buffer);\n            return;\n        }\n\n        // Reallocate the underlying buffer if needed\n        if (this.remaining < requiredLength) {\n            const previousArray = this.array;\n            const length = Math.max(previousArray.byteLength * 2, previousArray.byteLength + requiredLength);\n            this.buffer = new ArrayBuffer(length);\n            this.array = new Uint8Array(this.buffer);\n            this.array.set(previousArray);\n            this.remaining = length - this.offset;\n        }\n    }\n\n    /**\n     * Extract the complete message from the internal buffer as a view.\n     *\n     * Important: The returned message's underlying buffer will be reused with\n     *            the next chunk being reassembled.\n     *\n     * @return The completed message.\n     * @throws Error if the message is not yet complete.\n     */\n    public getMessage(): Uint8Array {\n        if (!this.complete) {\n            throw new Error('Message not complete');\n        }\n        const message = this.array.subarray(0, this.offset);\n        this.complete = false;\n        this.offset = 0;\n        this.remaining = this.buffer.byteLength;\n        return message;\n    }\n}\n\n/**\n * Reorders chunks and then copies them into a contiguous buffer.\n */\nclass UnreliableUnorderedReassembler {\n    private readonly contiguousChunks: ContiguousBufferReassembler = new ContiguousBufferReassembler();\n    private queuedChunks: Chunk[] | null = null;\n    private queuedChunksTotalByteLength: number = 0;\n    private _chunkCount: number = 0;\n    private nextOrderedSerial: number = 0;\n    private lastUpdate: number = new Date().getTime();\n    private requiredChunkCount: number | null = null;\n\n    /**\n     * Return the number of added chunks.\n     */\n    public get chunkCount(): number {\n        return this._chunkCount;\n    }\n\n    /**\n     * Return whether the message is complete, meaning that all chunks of the message arrived.\n     */\n    public get complete() {\n        return this.requiredChunkCount !== null && this._chunkCount === this.requiredChunkCount;\n    }\n\n    /**\n     * Add a new chunk.\n     *\n     * Important: Do not mix chunks with different ids in the same reassembler\n     *            instance or it will break!\n     *\n     * @throws Error if the message is already complete.\n     */\n    public add(chunk: Chunk): void {\n        // Already complete?\n        if (this.complete) {\n            throw new Error('Message already complete');\n        }\n\n        if (this.queuedChunks === null && chunk.serial === this._chunkCount) {\n            // In order: Can be added to the contiguous chunks\n            this.contiguousChunks.add(chunk);\n            this.nextOrderedSerial = chunk.serial + 1;\n        } else {\n            // Out of order: Needs to be temporarily stored in a queue\n            const ready = this.queueUnorderedChunk(chunk);\n            if (ready) {\n                // Queue is ready to be moved into the contiguous buffer.\n                this.moveQueuedChunks();\n            }\n        }\n\n        // Check if this is the last chunk received\n        if (chunk.endOfMessage) {\n            this.requiredChunkCount = chunk.serial + 1;\n        }\n\n        // Update chunk counter and timestamp\n        ++this._chunkCount;\n        this.lastUpdate = new Date().getTime();\n    }\n\n    /**\n     * Add a new chunk to its intended position in the out-of-order queue.\n     *\n     * Note: We continuously sort the queue by the serial number (ascending).\n     *\n     * @returns whether the queue is ready to be moved into the contiguous buffer.\n     */\n    private queueUnorderedChunk(chunk: Chunk): boolean {\n        // Append chunk\n        this.queuedChunksTotalByteLength += chunk.payload.byteLength;\n        if (this.queuedChunks === null) {\n            this.queuedChunks = [chunk];\n            return false;\n        }\n        this.queuedChunks.push(chunk);\n\n        // Sort chunk queue\n        this.queuedChunks.sort((a: Chunk, b: Chunk) => {\n            if (a.serial < b.serial) {\n                return -1;\n            }\n            if (a.serial > b.serial) {\n                return 1;\n            }\n            return 0;\n        });\n\n        // Check if ready\n        const iterator = this.queuedChunks.values();\n        let previousChunk = iterator.next().value;\n        if (previousChunk.serial !== this.nextOrderedSerial) {\n            return false;\n        }\n        for (const currentChunk of iterator) {\n            if (previousChunk.serial + 1 !== currentChunk.serial) {\n                return false;\n            }\n            previousChunk = currentChunk;\n        }\n        return true;\n    }\n\n    /**\n     * Moves the queued chunks to the contiguous buffer.\n     *\n     * Should be called once the queue contains consecutive chunks and there is\n     * no gap between the contiguous chunk buffer and our queued chunks.\n     */\n    private moveQueuedChunks(): void {\n        const chunk = this.contiguousChunks.addBatched(this.queuedChunks, this.queuedChunksTotalByteLength);\n        // Note: `chunk` is the last chunk in the sequence and has the highest serial number\n        this.nextOrderedSerial = chunk.serial + 1;\n        this.queuedChunks = null;\n    }\n\n    /**\n     * Get the reassembled message.\n     *\n     * @return The completed message.\n     * @throws Error if the message is not yet complete.\n     */\n    public getMessage(): Uint8Array {\n        if (!this.complete) {\n            throw new Error('Message not complete');\n        }\n        return this.contiguousChunks.getMessage();\n    }\n\n    /**\n     * Return whether last chunk is older than the specified number of milliseconds.\n     */\n    public isOlderThan(maxAge: number): boolean {\n        const age = (new Date().getTime() - this.lastUpdate);\n        return age > maxAge;\n    }\n}\n\n/**\n * An unchunker reassembles multiple chunks into a single message.\n */\nabstract class AbstractUnchunker implements chunkedDc.Unchunker {\n    /**\n     * Message listener. Set by the user.\n     *\n     * Important: The passed message's underlying buffer will be reused with\n     *            the next chunk being reassembled.\n     */\n    public onMessage: (message: Uint8Array) => void = null;\n\n    /**\n     * Notify message listener about a complete message.\n     */\n    protected notifyListener(message: Uint8Array) {\n        if (this.onMessage != null) {\n            this.onMessage(message);\n        }\n    }\n\n    /**\n     * Add a chunk.\n     *\n     * @param chunkArray A chunk containing either a 1 byte or 9 byte header.\n     *   Important: The chunk's underlying buffer should be considered transferred!\n     * @throws Error if message is smaller than the header length or an unknown\n     *   mode has been detected.\n     */\n    public abstract add(chunkArray: Uint8Array): void;\n}\n\n/**\n * An unchunker for reliable & ordered mode.\n */\nexport class ReliableOrderedUnchunker extends AbstractUnchunker implements chunkedDc.ReliableOrderedUnchunker {\n    private readonly reassembler: ContiguousBufferReassembler;\n\n    /**\n     * Create an unchunker for reliable & ordered mode.\n     *\n     * @param buffer A message buffer to be used for handing out messages.\n     *   If the message grows larger than the underlying buffer, it will be\n     *   replaced. A new buffer will be created when needed if not supplied.\n     */\n    public constructor(buffer?: ArrayBuffer) {\n        super();\n        this.reassembler = new ContiguousBufferReassembler(buffer);\n    }\n\n    /**\n     * Add a chunk.\n     *\n     * @param chunkArray A chunk containing a 1 byte header.\n     *   Important: The chunk's underlying buffer should be considered transferred!\n     * @throws Error if message is smaller than the header length or an unknown\n     *   mode has been detected.\n     */\n    public add(chunkArray: Uint8Array): void {\n        // Parse chunk\n        const chunk = new Chunk(chunkArray, Mode.ReliableOrdered, RELIABLE_ORDERED_HEADER_LENGTH);\n\n        // If this is a single chunk that contains the whole message, return it immediately.\n        if (this.reassembler.empty && chunk.endOfMessage) {\n            this.notifyListener(chunk.payload);\n            return;\n        }\n\n        // Add the chunk's payload to the message buffer.\n        this.reassembler.add(chunk);\n\n        // Check if message is complete\n        if (chunk.endOfMessage) {\n            // Hand out the message and reset the buffer\n            this.notifyListener(this.reassembler.getMessage());\n        }\n    }\n}\n\n/**\n * A reassembler optimised for unreliable & unordered mode.\n */\nexport class UnreliableUnorderedUnchunker extends AbstractUnchunker implements chunkedDc.UnreliableUnorderedUnchunker {\n    private reassemblers: Map<number, UnreliableUnorderedReassembler> = new Map();\n\n    /**\n     * Add a chunk.\n     *\n     * @param chunkArray A chunk containing a 9 byte header.\n     *   Important: The chunk's underlying buffer should be considered transferred!\n     * @throws Error if message is smaller than the header length or an unknown\n     *   mode has been detected.\n     */\n    public add(chunkArray: Uint8Array): void {\n        // Parse chunk\n        const chunk = new Chunk(chunkArray, Mode.UnreliableUnordered, UNRELIABLE_UNORDERED_HEADER_LENGTH);\n\n        // If this is a single chunk that contains the whole message, return it immediately.\n        if (chunk.endOfMessage && chunk.serial === 0) {\n            this.notifyListener(chunk.payload);\n            return;\n        }\n\n        // Add chunk to reassembler\n        let reassembler: UnreliableUnorderedReassembler = this.reassemblers.get(chunk.id);\n        if (reassembler === undefined) {\n            reassembler = new UnreliableUnorderedReassembler();\n            this.reassemblers.set(chunk.id, reassembler);\n        }\n        reassembler.add(chunk);\n\n        // Check if message is complete\n        if (reassembler.complete) {\n            // Hand out the message and delete the message's reassembler\n            this.notifyListener(reassembler.getMessage());\n            this.reassemblers.delete(chunk.id);\n        }\n    }\n\n    /**\n     * Run garbage collection, remove incomplete messages that haven't been\n     * updated for more than the specified number of milliseconds.\n     *\n     * If you want to make sure that invalid chunks don't fill up memory, call\n     * this method regularly.\n     *\n     * @param maxAge Remove incomplete messages that haven't been updated for\n     *               more than the specified number of milliseconds.\n     */\n    public gc(maxAge: number): number {\n        let removed = 0;\n        for (const [id, reassembler] of this.reassemblers) {\n            if (reassembler.isOlderThan(maxAge)) {\n                removed += reassembler.chunkCount;\n                this.reassemblers.delete(id);\n            }\n        }\n        return removed;\n    }\n}\n"],"names":["Mode","AbstractChunker","mode","headerLength","id","message","chunkLength","buffer","minChunkSize","Error","byteLength","Math","payloadLength","this","hasNext","done","value","chunkBuffer","remaining","offset","endOffset","ArrayBuffer","chunkView","DataView","options","setUint8","ReliableOrdered","UnreliableUnordered","setUint32","serial","payloadSlice","subarray","chunkArray","Uint8Array","set","Symbol","iterator","ReliableOrderedChunker","UnreliableUnorderedChunker","Chunk","expectedMode","byteOffset","getUint8","actualMode","getUint32","endOfMessage","payload","ContiguousBufferReassembler","array","chunk","complete","maybeResize","chunks","totalByteLength","requiredLength","previousArray","length","max","UnreliableUnorderedReassembler","Date","getTime","queuedChunks","_chunkCount","contiguousChunks","add","nextOrderedSerial","queueUnorderedChunk","moveQueuedChunks","requiredChunkCount","lastUpdate","queuedChunksTotalByteLength","push","sort","a","b","values","previousChunk","next","currentChunk","addBatched","getMessage","maxAge","AbstractUnchunker","onMessage","ReliableOrderedUnchunker","reassembler","empty","notifyListener","UnreliableUnorderedUnchunker","Map","reassemblers","get","undefined","delete","removed","isOlderThan","chunkCount"],"mappings":"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"}