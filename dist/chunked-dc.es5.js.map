{"version":3,"file":"chunked-dc.es5.js","sources":["../src/common.ts","../src/chunker.ts","../src/unchunker.ts","../src/main.ts"],"sourcesContent":["/**\n * Copyright (C) 2016-2018 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\nexport class Common {\n    public static HEADER_LENGTH = 9;\n}\n","/**\n * Copyright (C) 2016-2018 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\n/// <reference path='../chunked-dc.d.ts' />\n\nimport { Common } from './common';\n\n/**\n * A Chunker instance splits up an Uint8Array into multiple chunks.\n *\n * The Chunker is initialized with an ID. For each message to be chunked,\n * a new Chunker instance is required.\n */\nexport class Chunker implements chunkedDc.Chunker {\n\n    private id: number;\n    private chunkDataSize: number;\n    private chunkId: number = 0;\n    private message: Uint8Array;\n\n    /**\n     * Create a Chunker instance.\n     *\n     * @param id An identifier for the message. Must be between 0 and 2**32-1.\n     * @param message The Uint8Array containing the bytes that should be chunked.\n     * @param chunkSize The chunk size *including* header data.\n     */\n    constructor(id: number, message: Uint8Array, chunkSize: number) {\n        if (chunkSize < (Common.HEADER_LENGTH + 1)) {\n            throw new Error('Chunk size must be at least ' + (Common.HEADER_LENGTH + 1));\n        }\n        if (message.byteLength < 1) {\n            throw new Error('Array may not be empty');\n        }\n        if (id < 0 || id >= (2 ** 32)) {\n            throw new Error('Message id must be between 0 and 2**32-1');\n        }\n        this.id = id;\n        this.message = message;\n        this.chunkDataSize = chunkSize - Common.HEADER_LENGTH;\n    }\n\n    /**\n     * Whether there are more chunks available.\n     */\n    public get hasNext(): boolean {\n        const currentIndex = this.chunkId * this.chunkDataSize;\n        const remaining = this.message.byteLength - currentIndex;\n        return remaining >= 1;\n    }\n\n    /**\n     * Iterator implementation. Value is the next Uint8Array chunk.\n     */\n    public next(): IteratorResult<Uint8Array> {\n        if (!this.hasNext) {\n            return {\n                done: true,\n                value: null,\n            };\n        }\n\n        // Allocate chunk buffer\n        const currentIndex = this.chunkId * this.chunkDataSize;\n        const remaining = this.message.byteLength - currentIndex;\n        const chunkBytes = remaining < this.chunkDataSize ? remaining : this.chunkDataSize;\n        const chunk = new DataView(new ArrayBuffer(chunkBytes + Common.HEADER_LENGTH));\n\n        // Create header\n        const options = remaining > chunkBytes ? 0 : 1;\n        const id = this.id;\n        const serial = this.nextSerial();\n\n        // Write to chunk buffer\n        chunk.setUint8(0, options);\n        chunk.setUint32(1, id);\n        chunk.setUint32(5, serial);\n        for (let i = 0; i < chunkBytes; i++) {\n            const offset = Common.HEADER_LENGTH + i;\n            chunk.setUint8(offset, this.message[currentIndex + i]);\n        }\n        return {\n            done: false,\n            value: new Uint8Array(chunk.buffer),\n        };\n    }\n\n    /**\n     * Return and post-increment the id of the next block\n     */\n    private nextSerial(): number {\n        return this.chunkId++;\n    }\n\n    /**\n     * Return an iterator over the chunks.\n     */\n    public [Symbol.iterator](): IterableIterator<Uint8Array> {\n        return this;\n    }\n\n}\n","/**\n * Copyright (C) 2016-2018 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\n/// <reference path='../chunked-dc.d.ts' />\n\nimport { Common } from './common';\n\n/**\n * Helper class to access chunk information.\n */\nexport class Chunk {\n    private _endOfMessage: boolean;\n    private _id: number;\n    private _serial: number;\n    private _data: Uint8Array;\n    private _context: any;\n\n    /**\n     * Parse the ArrayBuffer.\n     */\n    constructor(buf: ArrayBuffer, context?: any) {\n        if (buf.byteLength < Common.HEADER_LENGTH) {\n            throw new Error('Invalid chunk: Too short');\n        }\n\n        // Read header\n        const reader = new DataView(buf);\n        const options = reader.getUint8(0);\n        // tslint:disable-next-line:no-bitwise\n        this._endOfMessage = (options & 0x01) === 1;\n        this._id = reader.getUint32(1);\n        this._serial = reader.getUint32(5);\n\n        // Read data\n        // Note: We copy the data bytes instead of getting a reference to a subset of the buffer.\n        // This is less ideal for performance, but avoids bugs that can occur\n        // by 3rd party modification of the ArrayBuffer.\n        this._data = new Uint8Array(buf.slice(Common.HEADER_LENGTH));\n\n        // Store context\n        this._context = context;\n    }\n\n    public get isEndOfMessage(): boolean {\n        return this._endOfMessage;\n    }\n\n    public get id(): number {\n        return this._id;\n    }\n\n    public get serial(): number {\n        return this._serial;\n    }\n\n    public get data(): Uint8Array {\n        return this._data;\n    }\n\n    public get context(): any {\n        return this._context;\n    }\n}\n\n/**\n * Helper class to hold chunks and an \"end-arrived\" flag.\n */\nclass ChunkCollector {\n    private endArrived: boolean;\n    private messageLength: number = null;\n    private chunks: Chunk[] = [];\n    private lastUpdate: number = new Date().getTime();\n\n    /**\n     * Register a new chunk. Return a boolean indicating whether the chunk was added.\n     */\n    public addChunk(chunk: Chunk): void {\n        // Ignore repeated chunks with the same serial\n        if (this.hasSerial(chunk.serial)) {\n            return;\n        }\n\n        // Add chunk\n        this.chunks.push(chunk);\n\n        // Process chunk\n        this.lastUpdate = new Date().getTime();\n        if (chunk.isEndOfMessage) {\n            this.endArrived = true;\n            this.messageLength = chunk.serial + 1;\n        }\n    }\n\n    /**\n     * Return whether this chunk collector already contains a chunk with the specified serial.\n     */\n    public hasSerial(serial: number): boolean {\n        return this.chunks.find(\n            (chunk: Chunk) => chunk.serial === serial,\n        ) !== undefined;\n    }\n\n    /**\n     * Return whether the message is complete, meaning that all chunks of the message arrived.\n     */\n    public get isComplete() {\n        return this.endArrived && this.chunks.length === this.messageLength;\n    }\n\n    /**\n     * Merge the messages.\n     *\n     * Note: This implementation assumes that no chunk will be larger than the first one!\n     * If this is not the case, an error may be thrown.\n     *\n     * @return An object containing the message as an `Uint8Array`\n     *         and a (possibly empty) list of context objects.\n     * @throws Error if message is not yet complete.\n     */\n    public merge(): {message: Uint8Array, context: any[]} {\n        // Preconditions\n        if (!this.isComplete) {\n            throw new Error('Not all chunks for this message have arrived yet.');\n        }\n\n        // Sort chunks\n        this.chunks.sort((a: Chunk, b: Chunk) => {\n            if (a.serial < b.serial) {\n                return -1;\n            } else if (a.serial > b.serial) {\n                return 1;\n            }\n            return 0;\n        });\n\n        // Allocate buffer\n        const capacity = this.chunks[0].data.byteLength * this.messageLength;\n        const buf = new Uint8Array(new ArrayBuffer(capacity));\n\n        // Add chunks to buffer\n        let offset = 0;\n        const firstSize = this.chunks[0].data.byteLength;\n        const contextList = [];\n        for (const chunk of this.chunks) {\n            if (chunk.data.byteLength > firstSize) {\n                throw new Error('No chunk may be larger than the first chunk of that message.');\n            }\n            buf.set(chunk.data, offset);\n            offset += chunk.data.length;\n            if (chunk.context !== undefined) {\n                contextList.push(chunk.context);\n            }\n        }\n\n        // Return result object\n        return {\n            message: buf.slice(0, offset),\n            context: contextList,\n        };\n    }\n\n    /**\n     * Return whether last chunk is older than the specified number of miliseconds.\n     */\n    public isOlderThan(maxAge: number): boolean {\n        const age = (new Date().getTime() - this.lastUpdate);\n        return age > maxAge;\n    }\n\n    /**\n     * Return the number of registered chunks.\n     */\n    public get chunkCount(): number {\n        return this.chunks.length;\n    }\n}\n\n/**\n * An Unchunker instance merges multiple chunks into a single Uint8Array.\n *\n * It keeps track of IDs, so only one Unchunker instance is necessary\n * to receive multiple messages.\n */\nexport class Unchunker {\n    private chunks: Map<number, ChunkCollector> = new Map();\n\n    /**\n     * Message listener. Set by the user.\n     */\n    public onMessage: (message: Uint8Array, context?: any[]) => void = null;\n\n    /**\n     * Add a chunk.\n     *\n     * @param buf ArrayBuffer containing chunk with 9 byte header.\n     * @param context Arbitrary data that will be registered with the chunk and will be passed to the callback.\n     * @throws Error if message is smaller than the header length.\n     */\n    public add(buf: ArrayBuffer, context?: any): void {\n        // Parse chunk\n        const chunk = new Chunk(buf, context);\n\n        // Ignore repeated chunks with the same serial\n        if (this.chunks.has(chunk.id) && this.chunks.get(chunk.id).hasSerial(chunk.serial)) {\n            return;\n        }\n\n        // If this is the only chunk in the message, return it immediately.\n        if (chunk.isEndOfMessage && chunk.serial === 0) {\n            this.notifyListener(chunk.data, context === undefined ? [] : [context]);\n            this.chunks.delete(chunk.id);\n            return;\n        }\n\n        // Otherwise, add chunk to chunks list\n        let collector: ChunkCollector;\n        if (this.chunks.has(chunk.id)) {\n            collector = this.chunks.get(chunk.id);\n        } else {\n            collector = new ChunkCollector();\n            this.chunks.set(chunk.id, collector);\n        }\n        collector.addChunk(chunk);\n\n        // Check if message is complete\n        if (collector.isComplete) {\n            // Merge and notify listener...\n            const merged = collector.merge();\n            this.notifyListener(merged.message, merged.context);\n            // ...then delete the chunks.\n            this.chunks.delete(chunk.id);\n        }\n    }\n\n    /**\n     * If a message listener is set, notify it about a complete message.\n     */\n    private notifyListener(message: Uint8Array, context: any[]) {\n        if (this.onMessage != null) {\n            this.onMessage(message, context);\n        }\n    }\n\n    /**\n     * Run garbage collection, remove incomplete messages that haven't been\n     * updated for more than the specified number of milliseconds.\n     *\n     * If you want to make sure that invalid chunks don't fill up memory, call\n     * this method regularly.\n     *\n     * @param maxAge Remove incomplete messages that haven't been updated for\n     *               more than the specified number of milliseconds.\n     * @return the number of removed chunks.\n     */\n    public gc(maxAge: number): number {\n        let removedItems = 0;\n        for (const entry of this.chunks) {\n            const msgId: number = entry[0];\n            const collector: ChunkCollector = entry[1];\n            if (collector.isOlderThan(maxAge)) {\n                removedItems += collector.chunkCount;\n                this.chunks.delete(msgId);\n            }\n        }\n        return removedItems;\n    }\n}\n","/**\n * Copyright (C) 2016-2018 Threema GmbH / SaltyRTC Contributors\n *\n * Licensed under the Apache License, Version 2.0, <see LICENSE-APACHE file>\n * or the MIT license <see LICENSE-MIT file>, at your option. This file may not be\n * copied, modified, or distributed except according to those terms.\n */\nimport { Common } from './common';\n\n// Export classes\nexport { Chunker } from './chunker';\nexport { Unchunker } from './unchunker';\n\n// Export constants\nexport const HEADER_LENGTH = Common.HEADER_LENGTH;\n"],"names":["Common","id","message","chunkSize","HEADER_LENGTH","Error","byteLength","Math","chunkDataSize","hasNext","done","value","currentIndex","chunkId","remaining","chunkBytes","chunk","DataView","ArrayBuffer","options","serial","nextSerial","setUint8","setUint32","i","offset","Uint8Array","buffer","Symbol","iterator","buf","context","reader","getUint8","_endOfMessage","_id","getUint32","_serial","_data","slice","_context","Date","getTime","hasSerial","chunks","push","lastUpdate","isEndOfMessage","endArrived","messageLength","find","undefined","isComplete","sort","a","b","capacity","data","firstSize","contextList","set","length","maxAge","age","Map","Chunk","has","get","notifyListener","delete","collector","ChunkCollector","addChunk","merged","merge","onMessage","removedItems","entry","msgId","isOlderThan","chunkCount"],"mappings":"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"}